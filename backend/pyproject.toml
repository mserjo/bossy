# # backend/pyproject.toml

[build-system]
requires = ["setuptools >= 61.0"]
build-backend = "setuptools.build_meta"
backend-path = ["."]

[project]
name = "bossy_backend"
version = "0.1.0"
description = "Backend for the Bossy bonus system application."
readme = "README.md" # Припускаючи, що README.md буде в backend/
authors = [
    { name = "Your Name / Company Name", email = "your.email@example.com" }, # TODO: Замінити на реальні дані
]
license = { text = "MIT" } # TODO: Уточнити ліцензію, якщо потрібно
requires-python = ">=3.11" # Згідно ТЗ Python 3.13, але для сумісності можна почати з 3.11 або 3.12
classifiers = [
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Framework :: FastAPI",
    "Topic :: Software Development :: Libraries :: Application Frameworks",
    "Operating System :: OS Independent",
]
# Залежності тут зазвичай не вказуються, якщо використовуються requirements.txt.
# Але для деяких інструментів (наприклад, Poetry, PDM) вони керуються тут.
# Оскільки ми використовуємо requirements.txt, секція [project.dependencies] може бути порожньою або відсутньою.
# dependencies = []

[project.urls]
Homepage = "https://github.com/mserjo/bossy" # TODO: Уточнити URL
Repository = "https://github.com/mserjo/bossy.git"

# --- Налаштування інструментів ---

[tool.black]
line-length = 119
target-version = ['py311', 'py312', 'py313']
# include = '\.pyi?$'
# exclude = '''
# /(
#     \.eggs
#   | \.git
#   | \.hg
#   | \.mypy_cache
#   | \.tox
#   | \.venv
#   | _build
#   | buck-out
#   | build
#   | dist
# )/
# '''

[tool.ruff]
# Дозволяє замінити flake8, isort, pyupgrade, pydocstyle та інші.
# https://beta.ruff.rs/docs/configuration/
# https://beta.ruff.rs/docs/rules/
line-length = 119
target-version = "py311" # Або найнижча підтримувана версія

# Увімкнути набір правил Pyflakes (F), Pycodestyle (E, W), isort (I)
# Повний список: https://beta.ruff.rs/docs/rules/
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # Pyflakes
    "I",  # isort
    "C",  # flake8-comprehensions
    "B",  # flake8-bugbear
    "A",  # flake8-builtins
    "UP", # pyupgrade
    # "D",  # pydocstyle (потребує налаштування convention)
    "N",  # pep8-naming
    "S",  # flake8-bandit (безпека)
    "ANN",# flake8-annotations (частково, деякі правила можуть бути надто строгими)
    "ASYNC", # flake8-async
    "TRY", # tryceratops (обробка винятків)
    "RUF", # Ruff-specific rules
]
ignore = [
    "E501", # line too long, handled by black/formatter
    "B008", # Do not perform function calls in argument defaults (може бути спірним)
    "ANN101", # Missing type annotation for `self` in method
    "ANN102", # Missing type annotation for `cls` in classmethod
    # "ANN401", # Any type (можна увімкнути для строгішої типізації)
]

[tool.ruff.per-file-ignores]
"__init__.py" = ["F401"] # Ignore unused imports in __init__.py
"tests/*" = ["S101"] # Ignore `assert` statements in tests (flake8-bandit)

[tool.ruff.isort]
# known-first-party = ["backend"] # Вказати кореневий пакет проекту
# force-single-line = true
# lines-after-imports = 2

# [tool.ruff.pydocstyle]
# convention = "google" # або "numpy", "pep257"

[tool.mypy]
python_version = "3.11" # Або найнижча підтримувана
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true # На початку проекту може бути корисно
# Потім можна зробити строгіше:
# disallow_untyped_defs = true
# disallow_incomplete_defs = true
# disallow_untyped_calls = true
# strict_optional = true
# no_implicit_optional = true

# Шляхи для перевірки (можна вказати тут або в командному рядку)
# files = ["app", "tests"]

# Виключення для певних файлів/каталогів
# exclude = ['alembic/env.py'] # Приклад

# Плагіни, якщо потрібні (наприклад, для SQLAlchemy, Pydantic)
# plugins = [
#   "sqlalchemy.ext.mypy.plugin",
#   "pydantic.mypy"
# ]
# Для SQLAlchemy 2.0 та Pydantic v2 плагіни можуть бути вже не настільки критичними
# або їх налаштування змінилося. Потрібно перевірити документацію.

[tool.pytest.ini_options]
# python_files = "test_*.py tests_*.py *_test.py *_tests.py"
# python_functions = "test_*"
# python_classes = "Test* *Tests"
asyncio_mode = "auto" # Для pytest-asyncio
# addopts = "-ra -q --cov=app --cov-report=html --cov-report=term" # Приклад налаштувань для pytest
# log_cli = true
# log_level = "INFO"

# TODO: Переглянути та доповнити налаштування `ruff` та `mypy` відповідно до потреб проекту.
# TODO: Узгодити `target-version` та `python_version` з реальною мінімальною версією Python, що буде використовуватися.
# TODO: Налаштувати `pre-commit` хуки, які будуть використовувати ці інструменти.
# TODO: Замінити "Your Name / Company Name" та email в секції [project].
# TODO: Перевірити та, за потреби, додати плагіни для Mypy (SQLAlchemy, Pydantic).
#       Для SQLAlchemy 2.0 та Pydantic 2.0 вбудована типізація значно покращилася.
#       Плагін `pydantic.mypy` зазвичай потрібен для Pydantic v1.
#       Для SQLAlchemy 2.0 плагін `sqlalchemy.ext.mypy.plugin` все ще може бути корисним.
#       Його потрібно буде додати до `requirements-dev.txt`, якщо він використовується.
#       `sqlalchemy-stubs` для SQLAlchemy 1.4, для 2.0 вже не потрібні.
# TODO: Якщо `README.md` буде на рівні всього проекту, а не в `backend/`, шлях потрібно буде виправити.
#       Або ж створити окремий `README.md` для backend.
# TODO: Додати `[project.scripts]` або `[project.entry-points.console_scripts]`, якщо будуть CLI команди.
# TODO: Додати `[tool.setuptools.packages.find]` або `[tool.setuptools.py-modules]`, якщо потрібно
#       для правильної побудови пакету, хоча для FastAPI додатку, що запускається через uvicorn,
#       це може бути не так критично, як для бібліотеки.
#       Зазвичай `packages = find:` з `[tool.setuptools.packages.find]` є хорошим варіантом.
#       Або вказати `packages = ["app"]` (якщо `app` - це основний пакет з кодом).
#       Для FastAPI проектів, де `backend/app/` є коренем коду, це може виглядати так:
#       [tool.setuptools.packages.find]
#       where = ["."]  # Шукати пакети в поточному каталозі (backend/)
#       include = ["app*"] # Включити 'app' та його підпакети
#       exclude = ["tests*"] # Виключити 'tests'
#       Або простіше, якщо структура `backend/src/app`:
#       [tool.setuptools]
#       package-dir = {"" = "src"} # Вказує, що пакети знаходяться в src/
#       packages = ["app"]

# Наразі, для простоти, залишаю мінімальну конфігурацію setuptools,
# оскільки основна мета - налаштування інструментів форматування/лінтингу.
# Файл `pyproject.toml` розміщено в `backend/`.
# Шляхи в налаштуваннях інструментів (наприклад, для mypy) мають бути відносні до `backend/`.
# Наприклад, `files = ["app", "tests"]` для mypy означатиме `backend/app` та `backend/tests`.
# Це стандартна поведінка, якщо `pyproject.toml` знаходиться в корені модуля/проекту, що перевіряється.
